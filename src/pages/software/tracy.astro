---
import Layout from '../../layouts/Layout.astro';
---

<Layout
  title="Tracy"
  theme="software"
  description="Tracy: graphical interface for processing single-molecule fluorescence data."
  navState="compact"
>
  <div class="bubble-field" aria-hidden="true">
    <canvas class="bubble-canvas"></canvas>
  </div>
  <section class="software-divider">
    <video
      class="divider-video"
      src="/videos/software-divider.mp4"
      autoplay
      muted
      loop
      playsinline
      preload="metadata"
    ></video>
  </section>
  <section class="container tools tracy-page">
    <article class="tool-block" id="tracy" data-expanded="true">
      <div class="tool-content">
        <h3 class="tool-name">
          <img class="tool-title-icon" src="/images/tracyicon.png" alt="" />
          Tracy
        </h3>
        <p class="meta">
          Graphical interface for processing single-molecule fluorescence data.
          Uses kymographs as references for robust particle tracking and organizes track behavior.
        </p>
        <div class="tool-links">
          <a class="download-link" href="https://github.com/sami-chaaban/Tracy" target="_blank" rel="noreferrer">
            <img src="/images/github.png" alt="" />
            GitHub
          </a>
          <div class="tool-downloads">
            <a class="download-link" href="https://cloud3.mrc-lmb.cam.ac.uk/index.php/s/56FrAYFam3pqXme" target="_blank" rel="noreferrer">
              <img src="/images/apple.png" alt="" />
              Download for Mac
            </a>
            <a class="download-link" href="https://cloud3.mrc-lmb.cam.ac.uk/index.php/s/LfTtRxQtsis6JTJ" target="_blank" rel="noreferrer">
              <img src="/images/windows.png" alt="" />
              Download for Windows
            </a>
          </div>
        </div>
      </div>
      <div class="tool-media">
        <picture>
          <source srcset="/images/tracy-hero.png" type="image/png" />
          <img class="tool-hero" src="/images/tracy-hero.png" alt="Tracy interface" loading="lazy" decoding="async" />
        </picture>
      </div>
      <div class="tool-readme" id="tracy-readme" aria-live="polite">
        <div class="tool-readme-layout">
          <aside class="readme-toc is-empty" aria-label="Table of contents">
            <div class="readme-toc-inner">
              <nav class="readme-toc-list"></nav>
            </div>
          </aside>
          <div class="tool-readme-body">
            <div class="tool-readme-content"></div>
          </div>
        </div>
      </div>
    </article>
  </section>
</Layout>

<script>
  const tracyContent = document.querySelector('#tracy .tool-readme-content');
  const tracyToc = document.querySelector('#tracy .readme-toc');
  const tracyTocList = document.querySelector('#tracy .readme-toc-list');
  const bubbleCanvas = document.querySelector('.bubble-canvas');
  const bubbleCtx = bubbleCanvas?.getContext('2d');
  const tocLinks = new Map();
  const readmeAnchorMap = new Map();
  let tocHeadings = [];

  const normalizeHash = (value) => {
    if (!value) return '';
    let decoded = value;
    try {
      decoded = decodeURIComponent(value);
    } catch {
      decoded = value;
    }
    return decoded
      .trim()
      .toLowerCase()
      .replace(/^#/, '')
      .replace(/^user-content-/, '');
  };

  const createIdleBubbles = () => {
    if (!bubbleCanvas || !bubbleCtx) return;
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    const count = 110;
    const particles = [];
    const drift = { x: 0.00002, y: -0.00001 };
    const jitterScale = 0.00004;
    const noiseScale = 0.00018;
    const maxSpeed = 0.01;
    const influenceRadius = 0.12;
    const baseColor = 'rgba(132, 187, 224, 0.09)';
    const fillColor = 'rgba(132, 187, 224, 0.025)';
    let pointer = null;
    let pointerPrev = null;
    let pointerTime = 0;
    let pointerStrength = 0;
    let rafId = null;
    let lastTs = 0;
    let width = 0;
    let height = 0;
    let dpr = 1;

    const rand = (min, max) => min + Math.random() * (max - min);

    const resizeCanvas = () => {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      width = window.innerWidth;
      height = window.innerHeight;
      bubbleCanvas.width = Math.floor(width * dpr);
      bubbleCanvas.height = Math.floor(height * dpr);
      bubbleCanvas.style.width = `${width}px`;
      bubbleCanvas.style.height = `${height}px`;
      bubbleCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    const resetParticles = () => {
      particles.length = 0;
      for (let index = 0; index < count; index += 1) {
        const angle = rand(0, Math.PI * 2);
        const baseSpeed = rand(0.00008, 0.0006);
        particles.push({
          x: Math.random(),
          y: Math.random(),
          vx: Math.cos(angle) * baseSpeed,
          vy: Math.sin(angle) * baseSpeed,
          baseSpeed,
          size: rand(3.5, 9),
        });
      }
    };

    const wrap01 = (value) => {
      if (value < 0) return value + 1;
      if (value >= 1) return value - 1;
      return value;
    };

    const updatePointer = (event) => {
      if (!width || !height) return;
      const now = performance.now() / 1000;
      const current = { x: event.clientX / width, y: event.clientY / height };
      if (pointerPrev && pointerTime) {
        const dt = Math.max(now - pointerTime, 1e-3);
        const dx = current.x - pointerPrev.x;
        const dy = current.y - pointerPrev.y;
        const distance = Math.hypot(dx, dy);
        const speed = distance < 1e-5 ? 0 : distance / dt;
        const target = Math.min(speed * 0.06, 1);
        pointerStrength = 0.8 * pointerStrength + 0.2 * target;
      } else {
        pointerStrength = 0;
      }
      pointerPrev = current;
      pointerTime = now;
      pointer = current;
    };

    const clearPointer = () => {
      pointer = null;
      pointerPrev = null;
      pointerTime = 0;
      pointerStrength = 0;
    };

    const draw = () => {
      bubbleCtx.clearRect(0, 0, width, height);
      bubbleCtx.lineWidth = 1;
      for (const particle of particles) {
        const px = particle.x * width;
        const py = particle.y * height;
        bubbleCtx.beginPath();
        bubbleCtx.arc(px, py, particle.size, 0, Math.PI * 2);
        bubbleCtx.fillStyle = fillColor;
        bubbleCtx.fill();
        bubbleCtx.strokeStyle = baseColor;
        bubbleCtx.stroke();
      }
    };

    const tick = (timestamp) => {
      if (!lastTs) lastTs = timestamp;
      const dt = Math.min(2.5, (timestamp - lastTs) / 40);
      lastTs = timestamp;

      for (const particle of particles) {
        particle.vx += rand(-jitterScale, jitterScale);
        particle.vy += rand(-jitterScale, jitterScale);

        const speed = Math.hypot(particle.vx, particle.vy);
        const target = Math.max(0.00005, Math.min(0.0012, particle.baseSpeed * (1 + rand(-0.05, 0.05))));
        const scale = target / Math.max(speed, 1e-6);
        const relax = 0.12;
        particle.vx *= 1 + relax * (scale - 1);
        particle.vy *= 1 + relax * (scale - 1);

        if (pointer && pointerStrength > 0) {
          const dx = pointer.x - particle.x;
          const dy = pointer.y - particle.y;
          const distance = Math.hypot(dx, dy);
          if (distance < influenceRadius) {
            const pull = (0.025 * pointerStrength) / (0.02 + distance);
            particle.vx += dx * pull;
            particle.vy += dy * pull;
            const pullSpeed = Math.hypot(particle.vx, particle.vy);
            if (pullSpeed > maxSpeed) {
              const speedScale = maxSpeed / pullSpeed;
              particle.vx *= speedScale;
              particle.vy *= speedScale;
            }
          }
        }

        particle.x = wrap01(particle.x + particle.vx * dt + rand(-noiseScale, noiseScale) + drift.x);
        particle.y = wrap01(particle.y + particle.vy * dt + rand(-noiseScale, noiseScale) + drift.y);
      }

      pointerStrength *= 0.985;
      draw();
      rafId = window.requestAnimationFrame(tick);
    };

    resizeCanvas();
    resetParticles();
    draw();

    const onResize = () => {
      resizeCanvas();
      draw();
    };

    window.addEventListener('resize', onResize);
    window.addEventListener('mousemove', updatePointer, { passive: true });
    window.addEventListener('mouseleave', clearPointer);
    window.addEventListener('blur', clearPointer);

    rafId = window.requestAnimationFrame(tick);

    window.addEventListener('pagehide', () => {
      if (rafId) {
        window.cancelAnimationFrame(rafId);
      }
      window.removeEventListener('resize', onResize);
      window.removeEventListener('mousemove', updatePointer);
      window.removeEventListener('mouseleave', clearPointer);
      window.removeEventListener('blur', clearPointer);
    }, { once: true });
  };

  const cleanReadmeHtml = (html, options = {}) => {
    const { stripTocBlock = true } = options;
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const headings = doc.querySelectorAll('h1, h2, h3');
    const firstHeading = headings[0];
    if (firstHeading) {
      const headingText = firstHeading.textContent?.trim().toLowerCase();
      if (!headingText || headingText === 'tracy') {
        firstHeading.remove();
      }
    }

    doc.querySelectorAll('a.anchor, .octicon-link, .octicon').forEach((node) => node.remove());

    const slugify = (text) =>
      text
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-');
    readmeAnchorMap.clear();
    const addHeadingMap = (key, targetId) => {
      if (!key || !targetId) return;
      readmeAnchorMap.set(key, targetId);
      const normalized = normalizeHash(key);
      if (normalized) {
        readmeAnchorMap.set(normalized, targetId);
        readmeAnchorMap.set(`user-content-${normalized}`, targetId);
      }
    };

    doc.querySelectorAll('a[name]').forEach((anchor) => {
      const name = anchor.getAttribute('name')?.trim();
      if (!name) return;
      if (!anchor.id) {
        anchor.id = name;
      }
      addHeadingMap(name, anchor.id);
    });

    doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
      const text = heading.textContent?.trim() || '';
      if (!text) return;
      let id = heading.getAttribute('id');
      const namedAnchor = heading.querySelector('a[name]');
      const namedAnchorId = namedAnchor?.getAttribute('name')?.trim();
      if (!id && namedAnchorId) {
        id = namedAnchorId;
        heading.setAttribute('id', id);
      }
      if (!id) {
        const slug = slugify(text);
        id = `user-content-${slug}`;
        heading.setAttribute('id', id);
      }
      const base = id.replace(/^user-content-/, '');
      addHeadingMap(base, id);
      const baseWithoutNumber = base.replace(/^\d+-/, '');
      if (baseWithoutNumber && baseWithoutNumber !== base) {
        addHeadingMap(baseWithoutNumber, id);
      }
      addHeadingMap(id, id);
      if (namedAnchorId) {
        addHeadingMap(namedAnchorId, id);
      }
    });

    doc.querySelectorAll('a[href*="#"]').forEach((link) => {
      const rawHref = link.getAttribute('href') || '';
      const hashIndex = rawHref.indexOf('#');
      if (hashIndex === -1) return;
      const hash = rawHref.slice(hashIndex + 1);
      if (!hash) return;
      const normalizedHash = normalizeHash(hash);
      const targetId = readmeAnchorMap.get(hash) || readmeAnchorMap.get(normalizedHash);
      if (targetId) {
        link.setAttribute('href', `#${targetId}`);
      }
    });

    if (stripTocBlock) {
      const isTocHeading = (text) => /^table of contents\b/i.test((text || '').trim());
      const tocHeading = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6')).find(
        (heading) => isTocHeading(heading.textContent)
      );
      if (tocHeading) {
        let current = tocHeading;
        while (current) {
          const next = current.nextElementSibling;
          const tag = current.tagName?.toLowerCase() || '';
          const text = (current.textContent || '').trim();
          current.remove();

          if (!next) break;

          const nextTag = next.tagName?.toLowerCase() || '';
          const nextText = (next.textContent || '').trim();
          const nextIsHeading = /^h[1-6]$/.test(nextTag);
          const nextIsBoundary =
            nextTag === 'hr' ||
            /^-{3,}$/.test(nextText) ||
            (nextIsHeading && !isTocHeading(nextText));

          if (nextIsBoundary) {
            if (nextTag === 'hr' || /^-{3,}$/.test(nextText)) {
              next.remove();
            }
            break;
          }

          current = next;
        }
      }
    }

    const firstImage = doc.querySelector('img');
    if (firstImage) {
      const parent = firstImage.parentElement;
      firstImage.remove();
      if (parent && parent.textContent.trim() === '' && parent.children.length === 0) {
        parent.remove();
      }
    }
    return doc.body.innerHTML;
  };

  const getHeaderOffset = () => {
    const raw = getComputedStyle(document.documentElement)
      .getPropertyValue('--header-offset')
      .trim();
    return Number.parseFloat(raw) || 96;
  };

  const updateActiveToc = () => {
    if (!tocHeadings.length || !tocLinks.size) return;
    const markerY = window.scrollY + getHeaderOffset() + 30;
    let activeId = tocHeadings[0].id;
    for (const heading of tocHeadings) {
      const top = heading.getBoundingClientRect().top + window.scrollY;
      if (top <= markerY) {
        activeId = heading.id;
      } else {
        break;
      }
    }
    tocLinks.forEach((link, id) => {
      link.classList.toggle('is-active', id === activeId);
    });
  };

  const extractTocEntriesFromMarkdown = (markdown) => {
    if (!markdown) return [];
    const lines = markdown.split(/\r?\n/);
    const startIndex = lines.findIndex((line) => /^\s*###\s+Table of Contents\b/i.test(line));
    if (startIndex === -1) return [];

    const entries = [];
    for (let index = startIndex + 1; index < lines.length; index += 1) {
      const line = lines[index];
      if (/^\s*---\s*$/.test(line)) break;
      const match = line.match(/^(\s*)(?:[-*+]|\d+\.)\s+\[([^\]]+)\]\((#[^)]+)\)/);
      if (!match) continue;
      const indent = match[1].replace(/\t/g, '  ').length;
      const level = Math.min(3, Math.floor(indent / 2) + 1);
      entries.push({
        label: match[2].trim(),
        hash: match[3].trim(),
        level,
      });
    }
    return entries;
  };

  const stripMarkdownTocBlock = (markdown) => {
    if (!markdown) return markdown;
    const lines = markdown.split(/\r?\n/);
    const startIndex = lines.findIndex((line) => /^\s*###\s+Table of Contents\b/i.test(line));
    if (startIndex === -1) return markdown;

    let endIndex = startIndex + 1;
    while (endIndex < lines.length) {
      if (/^\s*---\s*$/.test(lines[endIndex])) {
        endIndex += 1;
        break;
      }
      endIndex += 1;
    }

    const cleaned = [...lines.slice(0, startIndex), ...lines.slice(endIndex)];
    return cleaned.join('\n');
  };

  const findHeadingById = (targetId) => {
    if (!targetId || !tracyContent) return null;
    if (window.CSS?.escape) {
      return tracyContent.querySelector(`#${CSS.escape(targetId)}`);
    }
    return tracyContent.querySelector(`[id="${targetId.replace(/"/g, '\\"')}"]`);
  };

  const buildReadmeToc = (markdown) => {
    if (!tracyToc || !tracyTocList || !tracyContent) return;
    const tocEntries = extractTocEntriesFromMarkdown(markdown);

    tocHeadings = [];
    tocLinks.clear();
    tracyTocList.innerHTML = '';

    if (!tocEntries.length) {
      tracyToc.classList.add('is-empty');
      return;
    }

    const seen = new Set();
    const rootList = document.createElement('ul');
    rootList.className = 'readme-toc-root';
    let lastLevel1Item = null;
    let lastLevel2Item = null;

    const appendToParent = (item, level) => {
      if (level <= 1 || !lastLevel1Item) {
        rootList.appendChild(item);
        return;
      }

      if (level === 2) {
        let nested = lastLevel1Item.querySelector('.readme-toc-nested');
        if (!nested) {
          nested = document.createElement('ul');
          nested.className = 'readme-toc-nested';
          lastLevel1Item.appendChild(nested);
        }
        nested.appendChild(item);
        return;
      }

      if (lastLevel2Item) {
        let nested = lastLevel2Item.querySelector('.readme-toc-nested');
        if (!nested) {
          nested = document.createElement('ul');
          nested.className = 'readme-toc-nested';
          lastLevel2Item.appendChild(nested);
        }
        nested.appendChild(item);
        return;
      }

      let fallbackNested = lastLevel1Item.querySelector('.readme-toc-nested');
      if (!fallbackNested) {
        fallbackNested = document.createElement('ul');
        fallbackNested.className = 'readme-toc-nested';
        lastLevel1Item.appendChild(fallbackNested);
      }
      fallbackNested.appendChild(item);
    };

    tocEntries.forEach((entry) => {
      const normalized = normalizeHash(entry.hash);
      const targetId =
        readmeAnchorMap.get(normalized) ||
        readmeAnchorMap.get(entry.hash.replace(/^#/, '')) ||
        normalized;
      if (!targetId) return;

      const heading = findHeadingById(targetId);
      if (!heading) return;

      if (!seen.has(targetId)) {
        tocHeadings.push(heading);
        seen.add(targetId);
      }

      const link = document.createElement('a');
      link.className = 'readme-toc-link';
      link.href = `#${targetId}`;
      link.textContent = entry.label;
      link.dataset.level = String(entry.level);
      link.addEventListener('click', () => {
        requestAnimationFrame(updateActiveToc);
      });
      tocLinks.set(targetId, link);

      const item = document.createElement('li');
      item.className = `readme-toc-item level-${entry.level}`;
      item.appendChild(link);
      appendToParent(item, entry.level);

      if (entry.level === 1) {
        lastLevel1Item = item;
        lastLevel2Item = null;
      } else if (entry.level === 2) {
        lastLevel2Item = item;
      }
    });

    if (!tocHeadings.length || !tocLinks.size) {
      tracyToc.classList.add('is-empty');
      return;
    }

    tocHeadings.sort(
      (left, right) =>
        left.getBoundingClientRect().top + window.scrollY - (right.getBoundingClientRect().top + window.scrollY)
    );
    tracyTocList.appendChild(rootList);
    tracyToc.classList.remove('is-empty');
    updateActiveToc();
  };

  const loadMarked = () => {
    if (window.marked?.parse) {
      return Promise.resolve(window.marked);
    }
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js';
      script.async = true;
      script.onload = () => resolve(window.marked);
      script.onerror = reject;
      document.head.appendChild(script);
    });
  };

  const loadRawTracyReadme = async () => {
    const response = await fetch(
      'https://raw.githubusercontent.com/sami-chaaban/Tracy/main/README.md',
      { cache: 'no-store' }
    );
    if (!response.ok) {
      throw new Error(`Failed to load raw README (${response.status})`);
    }
    return response.text();
  };

  const loadTracyReadme = async () => {
    if (!tracyContent) return;
    tracyContent.innerHTML = '<p class="meta">Loading README...</p>';

    try {
      const markdown = await loadRawTracyReadme();
      const marked = await loadMarked();
      const markdownWithoutToc = stripMarkdownTocBlock(markdown);
      const html = marked.parse(markdownWithoutToc);
      tracyContent.innerHTML = cleanReadmeHtml(html, { stripTocBlock: false });
      buildReadmeToc(markdown);
    } catch (error) {
      try {
        const response = await fetch('https://api.github.com/repos/sami-chaaban/Tracy/readme', {
          headers: { Accept: 'application/vnd.github.v3.html' },
          cache: 'no-store',
        });
        if (!response.ok) {
          throw new Error(`Failed to load README (${response.status})`);
        }
        const html = await response.text();
        tracyContent.innerHTML = cleanReadmeHtml(html);
        buildReadmeToc('');
      } catch (fallbackError) {
        tracyContent.innerHTML = `
          <p class="meta">
            Unable to load the README right now, visit
            <a href="https://github.com/sami-chaaban/Tracy" target="_blank" rel="noreferrer">GitHub</a>.
          </p>
        `;
        buildReadmeToc('');
      }
    }
  };

  loadTracyReadme();
  createIdleBubbles();
  window.addEventListener('scroll', updateActiveToc, { passive: true });
  window.addEventListener('resize', updateActiveToc);
  window.addEventListener('hashchange', updateActiveToc);

  const zoomableHeros = document.querySelectorAll('.tool-hero:not(.no-zoom)');
  zoomableHeros.forEach((hero) => {
    hero.addEventListener('click', () => {
      const isZoomed = hero.classList.contains('is-zoomed');
      if (isZoomed) {
        hero.classList.remove('is-zoomed');
        return;
      }
      zoomableHeros.forEach((item) => {
        item.classList.remove('is-zoomed');
        item.removeAttribute('data-zoom-anchor');
      });
      if (!isZoomed) {
        const rect = hero.getBoundingClientRect();
        const anchor = rect.left <= window.innerWidth - rect.right ? 'left' : 'right';
        hero.dataset.zoomAnchor = anchor;
        hero.classList.add('is-zoomed');
      }
    });
  });
</script>

<style>
  :global(body) {
    background-color: var(--bg) !important;
    background-image: linear-gradient(160deg, var(--bg), var(--bg-2)) !important;
    background-attachment: scroll;
  }

  :global(body::before) {
    background-image: none;
    opacity: 0;
  }

  .bubble-field {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }

  .bubble-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .software-divider {
    width: 100vw;
    margin-left: calc(50% - 50vw);
    padding-top: clamp(2rem, 6vh, 5rem);
    margin-top: calc(-1 * var(--header-offset, 96px));
    margin-bottom: 2.5rem;
    overflow: hidden;
  }

  .divider-video {
    display: block;
    width: 100%;
    height: auto;
    border-radius: 0;
    margin-left: 50%;
    transform: translateX(-50%);
  }

  @media (max-width: 900px) {
    .divider-video {
      width: clamp(100%, 160vw, 220%);
    }
  }

  .tracy-page {
    width: 100%;
    max-width: none;
    margin: 0;
    padding-left: max(1.25rem, (100vw - 1100px) / 2);
    padding-right: max(1.25rem, (100vw - 1100px) / 2);
  }

  .tools {
    display: grid;
    gap: 2rem;
    width: 100%;
  }

  .tool-block {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: var(--grid-gap);
    padding: 0;
    border-radius: 0;
    background: transparent;
    border: none;
    box-shadow: none;
    scroll-margin-top: 120px;
    position: relative;
    width: 100%;
    box-sizing: border-box;
    min-width: 0;
  }

  .tool-label {
    text-transform: uppercase;
    letter-spacing: 0.28em;
    font-size: 0.7rem;
    color: var(--accent-2);
    font-weight: 600;
    margin: 0 0 0.8rem;
  }

  .tool-name {
    font-family: var(--font-display);
    font-size: clamp(2.8rem, 4vw, 4.1rem);
    margin: 0 0 0.8rem;
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
  }

  .tool-title-icon {
    width: 84px;
    height: 84px;
    object-fit: contain;
  }

  .tool-media {
    border-radius: var(--radius-md);
    background: linear-gradient(140deg, rgba(255, 255, 255, 0.08), transparent);
    border: 1px dashed var(--border);
    min-height: 220px;
    display: grid;
    place-items: center;
    overflow: visible;
    min-width: 0;
    width: 100%;
  }

  .tool-media picture {
    width: 100%;
    display: block;
  }

  .tool-links {
    display: grid;
    gap: 0.6rem;
    margin-top: 1.1rem;
    font-weight: 600;
    justify-items: start;
  }

  .tool-links a {
    color: var(--text);
  }

  .tool-links a:hover,
  .tool-links a:focus-visible {
    color: var(--accent);
  }

  .tool-downloads {
    display: grid;
    gap: 0.6rem;
    width: 100%;
  }

  .download-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  .download-link img {
    width: 18px;
    height: 18px;
  }

  .tool-hero {
    width: 100%;
    height: auto;
    max-width: 100%;
    object-fit: contain;
    border-radius: var(--radius-md);
    transition: transform 220ms ease, box-shadow 220ms ease, background-color 220ms ease;
    transform-origin: center;
    cursor: zoom-in;
    position: relative;
    z-index: 1;
    background-color: transparent;
  }

  .tool-hero.is-zoomed {
    transform: scale(2);
    box-shadow: var(--shadow-lg);
    z-index: 20;
    background-color: var(--surface);
  }

  .tool-hero[data-zoom-anchor='left'] {
    transform-origin: left center;
  }

  .tool-hero[data-zoom-anchor='right'] {
    transform-origin: right center;
  }

  .tool-readme {
    grid-column: 1 / -1;
    overflow: visible;
    margin-top: 0.5rem;
  }

  .tool-readme-layout {
    display: grid;
    grid-template-columns: minmax(200px, 250px) minmax(0, 1fr);
    gap: 1.4rem;
    align-items: start;
  }

  .readme-toc {
    min-width: 0;
    position: sticky;
    top: 0.7rem;
    align-self: start;
  }

  .readme-toc.is-empty {
    display: none;
  }

  .readme-toc-inner {
    padding: 0.82rem 1.02rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    background: rgba(6, 10, 9, 0.42);
    backdrop-filter: blur(6px);
  }

  .readme-toc-list {
    display: block;
  }

  .readme-toc-root,
  .readme-toc-nested {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .readme-toc-item.level-1 {
    margin-top: 0.18rem;
  }

  .readme-toc-item.level-1:first-child {
    margin-top: 0;
  }

  .readme-toc-nested {
    margin-top: 0.08rem;
    margin-left: 0 !important;
    padding-left: 0 !important;
    border-left: none;
  }

  .readme-toc-item.level-2,
  .readme-toc-item.level-3 {
    margin-top: 0.02rem;
  }

  .readme-toc-link {
    display: block;
    border-left: 2px solid transparent;
    border-radius: 8px;
    padding: 0.14rem 0.62rem 0.14rem 0.56rem;
    font-size: 0.92rem;
    color: #7dc3e6;
    transition: color 180ms ease, border-color 180ms ease, background 180ms ease, transform 180ms ease;
    position: relative;
  }

  .readme-toc,
  .readme-toc a,
  .readme-toc .readme-toc-link {
    color: #7dc3e6 !important;
  }

  .readme-toc-link:link,
  .readme-toc-link:visited {
    color: #7dc3e6 !important;
  }

  .readme-toc-link[data-level='1'] {
    font-weight: 700;
    letter-spacing: 0.01em;
    color: #7dc3e6 !important;
    padding: 0.2rem 0.62rem 0.2rem 0.56rem;
    margin-top: 0.42rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-left: 3px solid color-mix(in srgb, var(--accent) 80%, transparent);
  }

  .readme-toc-link[data-level='1']:hover,
  .readme-toc-link[data-level='1']:focus-visible,
  .readme-toc-link[data-level='1'].is-active {
    color: #a5d8f0 !important;
  }

  .readme-toc-link[data-level='2'] {
    font-weight: 600;
    padding-left: 0.6rem !important;
    font-size: 0.89rem;
    color: #7dc3e6;
    line-height: 1.2;
  }

  .readme-toc-link[data-level='3'] {
    font-size: 0.82rem;
    font-weight: 500;
    padding-left: 0.64rem !important;
    color: #7dc3e6;
    opacity: 0.92;
    line-height: 1.2;
  }

  .readme-toc-link[data-level='2']::before,
  .readme-toc-link[data-level='3']::before {
    content: '';
    position: absolute;
    left: 0.16rem;
    top: 50%;
    width: 4px;
    height: 4px;
    border-radius: 999px;
    background: color-mix(in srgb, var(--accent) 70%, var(--muted));
    transform: translateY(-50%);
    opacity: 0.65;
  }

  .readme-toc-link[data-level='2']::after,
  .readme-toc-link[data-level='3']::after {
    content: none;
  }

  .readme-toc-link:hover,
  .readme-toc-link:focus-visible {
    color: #a5d8f0 !important;
    border-left-color: color-mix(in srgb, var(--accent) 65%, transparent);
    background: rgba(255, 255, 255, 0.04);
  }

  .readme-toc-link.is-active {
    color: #b8e2f7 !important;
    border-left-color: var(--accent);
    background: rgba(255, 255, 255, 0.08);
    transform: translateX(2px);
  }

  .readme-toc-link:active {
    color: #b8e2f7 !important;
  }

  .tool-readme-body {
    max-height: none;
    opacity: 1;
    min-width: 0;
  }

  .tool-readme-content {
    padding: 0;
    border-radius: 0;
    border: none;
    background: transparent;
    color: var(--text);
    font-size: 0.98rem;
    line-height: 1.65;
  }

  .tool-readme-content :global(h2),
  .tool-readme-content :global(h3),
  .tool-readme-content :global(h4) {
    margin: 1.4rem 0 0.6rem;
    font-family: var(--font-display);
    scroll-margin-top: calc(var(--header-offset, 96px) + 1.5rem);
  }

  .tool-readme-content :global(h2) {
    color: #7dc3e6;
  }

  .tool-readme-content :global(h3),
  .tool-readme-content :global(h4) {
    color: color-mix(in srgb, #7dc3e6 82%, var(--text));
  }

  .tool-readme-content :global(p),
  .tool-readme-content :global(ul),
  .tool-readme-content :global(ol) {
    margin: 0.7rem 0;
  }

  .tool-readme-content :global(ul),
  .tool-readme-content :global(ol) {
    padding-left: 1.2rem;
  }

  .tool-readme-content :global(a) {
    color: #7dc3e6;
  }

  .tool-readme-content :global(img) {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
  }

  .tool-readme-content :global(pre) {
    background: rgba(7, 12, 10, 0.62);
    color: #eaf7f1;
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: 1rem;
    overflow: auto;
  }

  .tool-readme-content :global(code) {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;
    font-size: 0.9em;
    color: #eaf7f1;
  }

  .tool-readme-content :global(p code),
  .tool-readme-content :global(li code),
  .tool-readme-content :global(td code) {
    background: rgba(7, 12, 10, 0.5);
    border-radius: 6px;
    padding: 0.05rem 0.35rem;
  }

  @media (max-width: 900px) {
    .tool-block {
      grid-template-columns: 1fr;
      padding: 0;
    }

    .tool-media {
      min-height: 0;
    }

    .tool-readme-content {
      padding: 0;
    }

    .tool-hero {
      max-width: 100%;
    }

    .tool-readme-layout {
      grid-template-columns: 1fr;
      gap: 0.9rem;
    }

    .readme-toc {
      display: none;
    }
  }

  @media (max-width: 900px) {
    .tracy-page {
      padding: 0 1.8rem;
    }

    .software-divider {
      padding-top: calc(var(--header-offset, 96px) * 0.15);
      margin-top: 0;
      margin-bottom: 2rem;
    }
  }

  @media (max-width: 600px) {
    .tracy-page {
      padding: 0 1.2rem;
    }

    .software-divider {
      padding-top: 0;
      margin-top: 0;
    }
  }
</style>
